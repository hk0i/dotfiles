#!/bin/zsh

# Instructions:
# 0. source this file.
# 1. set a command prefix
# 2. define functions that use the prefix
# 3. call bootstrap_command function with prefix and pass all cli args
# 4. place script in ~/org/bin
# 5. set execute bit (chmod u+x ~/org/bin/your_command)

# Example:
# You work at facebook, command name could be `fb`, your script may look like:

# source bootstrap
# CMD_PREFIX="fb"
#
# ${CMD_PREFIX}_sayHi() { # says hello
#     echo "hi"
# }
# bootstrap_command "fb" "$@"

# you can invoke the command like this:
# $ fb sayHi

bootstrap_command() {
    # don't run bootstrap_command function unless called as a script
    [[ $ZSH_EVAL_CONTEXT =~ :file ]] && return

    cmdName="$1"
    if [ -z "$cmdName" ]; then
        echo "bootstrap_command: no subcommand specified";
        echo "Usage: "
        echo "\tbootstrap_command \"your_command_name\" \"\$@\""
        return
    fi

    if (( $# > 1 )); then
        shift
    else
        usage $1
        exit 1
    fi

    # make sure we actually *did* get passed a valid function name
    subCommand="$1"
    functionName="${cmdName}_${subCommand}"
    shift
    if declare -f "$functionName" >/dev/null 2>&1; then
        # invoke that function, passing arguments through
        "$functionName" "$@" # same as "$1" "$2" "$3" ... for full argument list
    else
        echo "Bootstrapper: Subcommand '$subCommand' not recognized ($functionName)" >&2
        # exit 1
    fi
}

usage() {
    cmdName="$1"
    echo "Usage:"
    echo "\t$cmdName <subcommand> [options]"
    echo
    echo "Available subcommands:"
    list "$cmdName"
}

list() {
    subCommand="$1"
    # fancy sed command to extract function names and their comments for what they do
    grep '^function' $(which $subCommand)|sed -rn 's/function.*}_([a-zA-Z_0-9]+).*# (.+)/\t\1\t\t\2/p'
}
